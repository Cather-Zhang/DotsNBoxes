# Dots and Boxes AI Agent

## 1. Responsiblities
    **Nicole Burgess**: Setting up the class configurations (Board, Edge, GameStatus, Minimax, main cpp and header files)
    Joanna Hu
        Implementing referee integration (in main.cpp)
    Cather Zhang 
        Implementing minimax, alpha-beta pruning and iterative deepening searching 

    Everybody did debugging and testing.

## 2. Instructions on compiling and running your program.
1. To compile the project, make sure you have gcc/g++ installed:
    $ g++ --version
    *I compiled on g++ 11.2.0*
2. Run the following command in terminal
    $ cd <code src folder>
    $ g++ main.cpp Edge.cpp GameStatus.cpp Board.cpp Minimax.cpp -o BotsNDoxes

## 3. The utility function that your program uses.
    (maxscore - minscore) * 100


## 4. The evaluation function that your program uses.
    (maxscore - minscore) * 100
    for each chain squares we create for opponent, it is -80 * (# of squares in chain); +80 otherwise

## 5. The heuristics and/or strategies that you employed to decide how to expand nodes of the minimax tree without exceeding your time limit.
    Iterative deepening search: gradually increase max_depth for minimax algorithm within allowed time limit.
    Minimax algorithm with end_time limit: force exit out of the function and return pair(-1, empty list) if the time limit is reached

## 6. Results:
### Testing
1. Our AI agent played against a human (us) by manually typing the opponent's move in move_file and extending the time limit
2. Our AI agent against itself (with a different team name)
3. Test moves generated by our AI agent with a given board configuration

### Strengths and weaknesses
Strength: Minimizing number of chains that are give to opponent (defense strategy);
          Maximizing number of chains that we can score on (scoring strategy);
          Maximizing our use of the 10 seconds provided; 
          Relatively effective heuristic.

Weakness: Potential memory leak (there are some places where we did not free memory);
          Iterative deepening search only search for max depth = 4 in the beginning;
          Iterative deepening search does not reuse trees expended previously due to issues with freeing memory in the end.

## Analysis on evaluation function and the heuristic(s)
1. Chain heuristic: able to calculate the number of chains created by a certain move to avoid creating such chain for opponent to score on
2. Minimax alpha beta pruning: added end time limit that the program needs to exit by
3. Iterative deepening search: attempt to complete as many depth of searches as possible, but break out if we can't and return the most recent complete search
4. Child nodes generation: most promising children (the ones that score) are put at the beginning of the list to be searched